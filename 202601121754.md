---
tags:
  - "#card"
  - aif
  - logic
cards-deck:
---
#flashcards/aif/logic2

## First order logic

### Why FOL is more powerful than Propositional logic?
?
- FOL is more complex
	- in PL we have just logical operators and symbols.
- In FOL we can even express relations between objects and functions.
<!--SR:!2026-01-19,3,250-->

### What syntax construct we have in FOL?
?
- Constants
- Predicates
- Functions
- Variables
- Connectives
- Equality
- Quantifiers
<!--SR:!2026-01-20,4,270-->

### How do we call sentences in FOL?

#### What are terms?
?
A term is a logical expression referring to an object. It can be:
- a function applied to term's symbols
- a constant
- a variable
<!--SR:!2026-01-19,3,250-->

#### What is an Atomic Sentence?
?
An atomic sentence is a predicate applied to terms.
<!--SR:!2026-01-19,3,250-->

#### What is a Complex Sentence?
?
A complex sentence is a union of atomic sentences linked by connectives.
<!--SR:!2026-01-20,4,270-->

### What is a model
?
A model is a set
- of domain objects
- and their relations
<!--SR:!2026-01-19,3,250-->

### What is an interpretation?
?
An interpretation is a mapping
- that assigns a specific meaning to model's object
<!--SR:!2026-01-19,2,230-->

### What's the value of a sentence wrt a given model and interpretation?
?
The value of a sentence depends on how the interpretation maps each model object.
<!--SR:!2026-01-19,2,230--> 

### What's the Closed-world assumption?
?
If a sentence is not known to be true in our KB, then we can assume it is false.
<!--SR:!2026-01-20,4,270--> 

### Is it possible to check entailment via enumeration in FOL?
?
It's possible but it's very hard. Model checking is computationally expensive:
- if we tried to enumerate all models to check entailment
	- they might be infinite numbers of objects and relations
- it's not very smart
<!--SR:!2026-01-20,4,270-->

### Define the Universal Quantifier
?
With universal quantifier we can say that a statement is true for every object $x$ in the model.
> chain of AND statements
<!--SR:!2026-01-20,4,270-->

### Define the Existential Quantifier
?
With existential quantifier we can say that a statement is true for at least one object $x$ in the model.
> chain of OR statements
<!--SR:!2026-01-19,3,250-->

### What's quantifier duality?
?
We can express one using the other negation.
$$\lnot\exists x.P \equiv \forall x.\lnot P$$
<!--SR:!2026-01-20,4,270-->

### What is a substitution $\sigma$ in FOL?
?
Given some predicate $S(x,y)$ a substitution $\sigma$ assigns constant values to variable $x$ and $y$. $$S(x,y),\;\sigma=\{ x/A,\; y/B \}\quad S\sigma=S(A,B)$$
<!--SR:!2026-01-20,4,270--> 

### What is universal instantiation?
#### What happen to KB when we apply Universal Instantiation?
When we apply UI we are adding new sentences to the KB. $$\forall x.f(x) \implies f(1),\ldots,f(n) \text{ are added}$$ and removing the universal quantifiers.

### What is existential instantiation?
#### Does applying Existential Instantiation (EI) produce a logically equivalent KB? Why or why not?
?
NO, they are not logically equivalent.
- When we apply EI we skolemize the variable with a placeholder.
- So we create a new different sentence with the skolem constant.
<!--SR:!2026-01-20,4,270-->

#### What is a Skolem Constant?
?
A skolem constant $k$ is used to substitute a variable inside an existential quantification. It's a placeholder name for an object that
- we know exists
- but haven't identified yet
<!--SR:!2026-01-20,4,270-->

#### In which instantiation we use Skolem Constant and why?
?
Existential instantiation. Because
1. We cannot use a variable.
2. We cannot use an existing constant
<!--SR:!2026-01-19,3,250-->

#### Why can't we use an existing constant (like John) when performing Existential Instantiation?
?
Because John is a specific object, so using John excludes any other object in the model to be part of that existential instantiation. For this reason we use skolemization with placeholder $k$.
<!--SR:!2026-01-20,4,270-->

### Is it possible to reduce FOL in Propositional Logic?
?
Yes, FOL can be reduce to propositional logic. But it creates a lot of useless sentences.
<!--SR:!2026-01-19,3,250-->

#### What's a ground terms?
?
Term that does not contain any variables. If $a$ and $b$ are constants then $$q(a)$$ is a ground term.
<!--SR:!2026-01-19,2,230-->


#### Does FOL propositionalization preserve entailment?
?
Yes, by Herbrand's Theorem
> If a sentence is entailed by the KB, there is a finite proof using ground terms.
<!--SR:!2026-01-19,3,250--> 

#### Why does the presence of Function Symbols make the number of ground terms infinite?
?
Because a Function applied to a constant is a ground term, so we can freely chain them $$F(F(F(\ldots(\text{John})))$$
<!--SR:!2026-01-19,2,230-->

#### What is Herbrand's Theorem?
?
A theorem that connects FOL and PL
$$KB_{FOL}\vDash a \implies KB_{PL}\vDash a \quad KB_{PL}\text{ is finite size}$$
> If a sentence is entailed by the KB, there is a finite proof using ground terms.
<!--SR:!2026-01-19,3,250--> 


#### Why is FOL only **Semi-Decidable** according to Herbrand?
?
Infinitely ground terms can't get to a proof of entailment in PL.
<!--SR:!2026-01-19,2,230-->

#### Does exists a theorem that guarantee finite proof via ground terms on sentence entailed by KB?
?
Herbrand's Theorem does, $$KB_{FOL}\vDash a \implies KB_{PL}\vDash a \quad KB_{PL}\text{ is finite size}$$
<!--SR:!2026-01-20,4,270-->

### What's the downside of propositionalization in FOL?
?
We got a lot of useless sentences, most of them repeats the same concepts
<!--SR:!2026-01-20,4,270-->

#### How we can mitigate the propositionalization problem in FOL?
?
Using unification, finding a substitution $\theta$ that makes two different terms identical $$\text{Unify}(A,B)= \theta$$
<!--SR:!2026-01-20,4,270-->

#### How does Unification allow us to skip the 'Reduction to Propositional Logic' step?
?
Unification prevents us from replacing a variable with every single object in the model.
<!--SR:!2026-01-20,4,270-->

#### What's the limitation of unification in FOL?
?
We can't unify overlapping variables, in that case we use **Standardizing apart** to introduce a fresh variable that breaks the overlap.
<!--SR:!2026-01-20,4,270-->

#### Unification fails if the same variable name $(x)$ is used in both sentences for different values. What is the technique to fix this?
?
**Standardizing apart**, introduce a fresh variable that breaks the overlap.
<!--SR:!2026-01-20,4,270-->

#### What's Generalized Modus Ponens?
?
Is the foundation of inference in FOL $$\frac{\overbrace{p'_1,\ldots,p'_n}^{\text{FACTS}}\quad \overbrace{\overbrace{p_1\land\ldots\land p_n}^{\text{premises}}\implies q}^{\text{RULE}}}{q\theta}$$ given some facts, a rule and a substitution $\theta$:
- if we can find a valid substitution
	- that makes the premises of the rule
	- match the facts
- then we can generate the conclusion, applying that same substitution
<!--SR:!2026-01-19,2,230-->

##### What does GMP leverage to deal with variables?
?
Unification of $p$ and $p'$ with $q\theta$.
<!--SR:!2026-01-20,4,270-->

##### Why we use Unification in Generalized Modus Ponens?
?
To deal with variables, we simplify all the useless ground term substitution (that we found in propositionalization)
<!--SR:!2026-01-19,3,250-->

##### Is Generalized Modus Ponens sound?
?
Yes, we derive only true facts.
<!--SR:!2026-01-20,4,270-->

##### Is Generalized Modus Ponens complete?
?
No, it only handles definite clauses.
- it cannot derive conclusions from
	- general negations
	- disjunctions
<!--SR:!2026-01-20,4,270-->

### What's a definite clause?
?
Is a sentence that contains exactly one positive literal
1. A fact $$B$$ this is simply true
2. An implication (rule) $$p_1\land\ldots\land p_n \implies q$$ if all premises are true, then the conclusion is true
<!--SR:!2026-01-19,2,230-->

#### Why we apply Generalized Modus Ponens to definite clause?
?
The GMP itself is based on the implication form. I can say that is very efficient to deal with definite clause (forward and backward chaining).
<!--SR:!2026-01-19,2,230-->

### How many ways exists to use GMP with Definite Clauses?
?
1. Forward Chaining
2. Backward Chaining
<!--SR:!2026-01-20,4,270-->

#### Forward Chaining
?
From premises we infers new facts until we got to a conclusion.
![[Drawing 2026-01-13 19.05.47.excalidraw]]
<!--SR:!2026-01-19,2,230-->

##### Is Forward Chaining sound?
?
Yes, we use premises to derive new facts. We derive true things from known things.
<!--SR:!2026-01-20,4,270-->

##### Is Forward Chaining complete?
?
Yes, if the conclusion is correct then we can find it starting from premises.
<!--SR:!2026-01-19,3,250-->

#### Backward Chaining
?
Starting from goal, we derive facts and by applying valid substitutions we get to premises. ![[Drawing 2026-01-13 19.35.42.excalidraw]]
<!--SR:!2026-01-20,3,258-->

##### Is Backward Chaining sound?
?
Yes, we derive just true things.
<!--SR:!2026-01-20,3,258-->

##### Is Backward Chaining complete?
?
No, it's like a DFS. If we get in a loop we can't escape.
<!--SR:!2026-01-20,4,270-->

#### Which Chaining is more expensive?
?
Forward chaining, we might explore more than what we really need.
<!--SR:!2026-01-20,4,270-->

### What's prolog?
?
Is a logic declarative programming language
- write the facts and rules
	- prolog finds the solution
- If Prolog cannot prove something is true
	- it returns **False**
	- closed world assumption
<!--SR:!2026-01-19,3,250-->

#### How prolog works?
?
It performs **Backward Chaining** on **Horn Clauses** (Definite clauses).
<!--SR:!2026-01-20,3,250-->

#### Prolog uses Backward Chaining. Under what condition is this algorithm incomplete?
?
It is incomplete
- if the search space is **infinite**
- or if there are **loops**
	- e.g., A implies B, B implies A
	- Prolog uses Depth-First Search, so it dives down the rabbit hole and never comes back.
<!--SR:!2026-01-19,3,250-->

#### What type of clauses does Prolog/GMP handle?
?
Definite clauses.
<!--SR:!2026-01-20,4,270-->

### Why do we need Resolution in FOL?
?
GMP can be applied just to definite clauses. So we need something more for disjunctions and negations.
<!--SR:!2026-01-20,4,270-->

#### Is Resolution in FOL Complete and Sound?
?
Is sound and complete
- will always find a contradiction if one exists
	- might loop forever if no contradiction exists
<!--SR:!2026-01-20,4,270-->

#### How Resolution in FOL works?
?
By proofing contradiction.
<!--SR:!2026-01-19,3,250-->

#### Resolution proves $KB \vDash\alpha$ by showing that [BLANK] is unsatisfiable.
?
$KB\land\lnot\alpha$
<!--SR:!2026-01-20,4,270-->

#### Which sentences form Resolution in FOL requires?
?
CNF, conjuction normal form
<!--SR:!2026-01-20,4,270-->

#### What is the **first step** in converting a FOL sentence to CNF (regarding implications)?
?
Elimination of implications.
<!--SR:!2026-01-20,4,270-->

#### When moving negation inwards in CNF conversion, how do **Quantifiers** change?
?
By duality, negation of existance means universal negation.
<!--SR:!2026-01-20,4,270-->

#### In CNF conversion, why do we Standardize Variables (e.g., renaming x to z in the second clause) before dropping quantifiers?
?
Else unification doesn't work with variable that has same name.
<!--SR:!2026-01-20,4,270--> 

#### At last step of Resolution in FOL, what is the return value when a contradiction is found?
?
Empty clause.
<!--SR:!2026-01-20,4,270-->

#### In CNF conversion, how do we handle Existential Quantifiers ($\exists$) that appear inside the scope of a Universal Quantifier ($\forall$)?
?
We use a Skolem Function, not a constant.
<!--SR:!2026-01-20,4,270-->

#### What is the final form of a sentence after CNF conversion (what connects the literals)?
?
Conjuction, so they are connected by AND.
<!--SR:!2026-01-20,4,270-->

#### At the end of CNF conversion, what happens to the **Universal Quantifiers** ($\forall$)?
?
We drop it
<!--SR:!2026-01-20,4,270-->