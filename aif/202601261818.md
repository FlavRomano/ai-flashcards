---
tags:
  - "#card"
  - aif
  - csp
---

#flashcards/aif/csp

### **Part 1: Definitions and Representations**

### Atomic vs. Factored State
?
**Atomic State:** The state is a "black box" with no internal structure (used in standard search like A*).
**Factored State:** The state has internal structure, represented by a set of variables and values. This allows for general-purpose algorithms (CSPs).

### CSP Definition $(X, D, C)$
?
A Constraint Satisfaction Problem is defined by:
*   **$X$:** A set of variables $\{X_1, \dots, X_n\}$.
*   **$D$:** A set of domains $\{D_1, \dots, D_n\}$ (possible values for variables).
*   **$C$:** A set of constraints specifying allowable combinations of values.

### Assignments in CSP
?
*   **Partial Assignment:** Only some variables have been assigned values.
*   **Complete Assignment:** Every variable has an assigned value.
*   **Consistent Assignment:** An assignment that does not violate any constraints.

### The Goal of a CSP
?
To find a **Complete** and **Consistent** assignment (a value for every variable such that all constraints are satisfied).

### Constraint Graph
?
A visualization of a CSP where:
*   **Nodes** = Variables.
*   **Arcs (Edges)** = Constraints between variables.

### Hyper-graph in CSP
?
A graph used when constraints involve **more than two** variables (Global constraints).
*   *Note:* For finite domains, hyper-graphs can always be reduced to standard graphs with binary constraints (though this may not be efficient).

---

### **Part 2: Types of Constraints**

### Unary Constraint
?
Restricts the value of a **single** variable.
*   *Example:* $A \neq 1$ or $SouthAustralia \neq Green$.

### Binary Constraint
?
Relates **two** variables.
*   *Example:* $A \le B$ or $NSW \neq Victoria$.

### Global Constraint
?
Involves an arbitrary number of variables (not necessarily *all* variables, just more than 2).
*   *Example:* `Alldiff(A, B, C)` implies A, B, and C must all be different.
*   *Example:* Cryptarithmetic puzzles ($TWO + TWO = FOUR$).

### Preference Constraints
?
"Soft" constraints that indicate which solutions are preferred, rather than absolutely required.
*   This turns the CSP into a **Constrained Optimization Problem**.

---

### **Part 3: Basic Search Algorithms**

### Commutativity in CSP
?
The order in which variables are assigned does not change the final satisfying assignment.
*   *Implication:* We do not need to check all permutations ($n!$). We can fix the order of variables and just search for values.

### Backtracking Search
?
A depth-first search (DFS) algorithm for CSPs.
1.  Choose an unassigned variable.
2.  Try a value.
3.  If consistent, recurse.
4.  If failure, remove value (backtrack) and try the next value.

### Complexity of CSP Search
?
*   **Worst Case (General):** $O(d^n)$ where $d$ is domain size and $n$ is number of variables.
*   **Naive Search (without commutativity):** $O(n! \cdot d^n)$.

---

### **Part 4: Heuristics (Speeding up Search)**

### MRV Heuristic
?
**Minimum Remaining Values** (Variable Selection).
*   **Rule:** Choose the unassigned variable with the **fewest** legal values left.
*   **Philosophy:** "Fail First." Prune the tree early by tackling the variable most likely to cause a failure soon.

### Degree Heuristic
?
**Degree Heuristic** (Variable Selection - Tie Breaker).
*   **Rule:** Choose the variable involved in the **most constraints** on other *unassigned* variables.
*   **Usage:** Used as a tie-breaker when MRV yields multiple variables.

### LCV Heuristic
?
**Least Constraining Value** (Value Selection).
*   **Rule:** Given a variable, choose the value that rules out the **fewest** choices for the neighboring variables.
*   **Philosophy:** "Fail Last" (Optimistic). Leave the maximum flexibility for future assignments.

---

### **Part 5: Inference (Pruning)**

### Forward Checking
?
A simple inference method performed whenever a variable $X$ is assigned.
*   **Action:** Look at all unassigned neighbors $Y$. Delete any value from $Y$'s domain that conflicts with $X$'s new assignment.
*   **Result:** If a domain becomes empty, backtrack immediately.

### Arc Consistency (Definition)
?
A variable $X$ is arc-consistent with respect to $Y$ if:
For **every** value in $X$'s domain, there exists some allowed value in $Y$'s domain that satisfies the binary constraint.

### AC-3 Algorithm
?
An algorithm to enforce Arc Consistency on the entire graph.
*   **Queue:** Starts with all arcs.
*   **Process:** Pop $(X_i, X_j)$. Remove inconsistent values from $X_i$. If values were removed, add neighbors pointing to $X_i$ back to the queue.
*   **Complexity:** $O(cd^3)$ for binary constraints.

### MAC (Maintaining Arc Consistency)
?
A strategy that runs AC-3 after **every** individual assignment during the Backtracking Search.
*   It provides much stronger pruning than Forward Checking but is more computationally expensive per step.

---

### **Part 6: Local Search**

### Local Search for CSP (Concept)
?
Instead of building a solution from scratch (constructive), start with a **complete** (but inconsistent) assignment and iteratively improve it.

### Min-Conflicts Heuristic
?
The heuristic used in Local Search.
*   **Rule:** Choose a variable with conflicts. Change its value to the one that results in the **minimum number of conflicts** with other variables.
*   **Performance:** Astonishingly effective. Solves **N-Queens** in roughly constant time ($~50$ steps) regardless of $N$.

---

### **Part 7: Problem Structure**

### Independent Subproblems
?
Parts of the constraint graph that are not connected to each other (Connected Components).
*   **Benefit:** They can be solved separately.
*   **Scaling:** Reduces complexity from $O(d^n)$ to $O(d^c)$ where $c$ is the size of the largest component.

### Tree-Structured CSPs
?
A CSP where the constraint graph has no loops (is a tree).
*   **Complexity:** Solvable in **Linear time** $O(nd^2)$.

### Tree-CSP Algorithm
?
1.  **Topological Sort:** Order variables parent-to-child.
2.  **Backward Pass:** Enforce Arc Consistency from leaves up to root.
3.  **Forward Pass:** Assign values from root to leaves (Backtracking is never needed).

### Cutset Conditioning
?
A method to solve nearly-tree graphs.
1.  Identify a **Cutset** (variables that, if removed, turn the graph into a tree).
2.  Assign values to the Cutset variables.
3.  Solve the remaining tree.
*   **Complexity:** $O(d^c \cdot (n-c)d^2)$, where $c$ is the cutset size.