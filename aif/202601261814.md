---
tags:
  - "#card"
  - aif
  - search
---

#flashcards/aif/search

## Part 1: Search Strategy Basics

### Search Node Components
?
In a search tree, a node usually tracks four specific pieces of information to construct the solution path. What are they?
*   **Parent:** The node that generated this node.
*   **Action:** The action applied to the parent to generate this node.
*   **Path Cost $g(n)$:** The cost from the initial state to the node.
*   **Depth:** The number of steps from the root.
<!--SR:!2026-01-27,1,230-->

### Evaluation Dimensions
?
What are the four dimensions used to evaluate a search strategy?
1.  **Completeness:** Does it always find a solution if one exists?
2.  **Time Complexity:** How many nodes are generated/expanded?
3.  **Space Complexity:** What is the maximum number of nodes kept in memory?
4.  **Optimality:** Does it always find the least-cost solution?
<!--SR:!2026-01-29,3,250-->

### Complexity Variables
?
When measuring time and space complexity in search algorithms, what do the variables **$b$**, **$d$**, and **$m$** represent?
*   **$b$**: Maximum branching factor of the search tree.
*   **$d$**: Depth of the shallowest (least-cost) solution.
*   **$m$**: Maximum depth of the state space (may be $\infty$).
<!--SR:!2026-01-29,3,250-->

### Tree Search vs. Graph Search
?
What is the fundamental difference between **Tree Search** and **Graph Search** regarding repeated states?
*   **Tree Search:** Does not check for repeated states; it may visit the same state multiple times via different paths.
*   **Graph Search:** Maintains a "visited" list (closed set) to remember all reached states and avoids re-expanding them.
<!--SR:!2026-01-27,1,230-->

---

## Part 2: Uninformed Search Algorithms

### Breadth-First Search (BFS) Mechanics
?
Which node does BFS expand next, and what data structure is used for the frontier?
*   **Expansion:** It expands the **shallowest** unexpanded node.
*   **Frontier:** It uses a **FIFO (First-In-First-Out) queue**.
<!--SR:!2026-01-29,3,250-->

### BFS Complexity
?
What are the Time and Space complexities of Breadth-First Search?
*   **Time:** $O(b^d)$
*   **Space:** $O(b^d)$ (It keeps every generated node in memory).
*   *Note:* Space is the biggest problem for BFS; it fills memory quickly.
<!--SR:!2026-01-29,3,250-->

### BFS Optimality & Completeness
?
Is BFS Complete and Optimal?
*   **Complete:** Yes (provided $b$ is finite).
*   **Optimal:** Yes, **only if** step costs are identical (e.g., cost = 1 per step). It is *not* optimal for general costs.
<!--SR:!2026-01-29,3,250-->

### Uniform-Cost Search (UCS) Mechanics
?
How does Uniform-Cost Search (Dijkstra's) differ from BFS?
*   **Expansion:** It expands the node with the **lowest path cost** $g(n)$.
*   **Frontier:** It uses a **Weighted Queue** (Priority Queue) ordered by path cost.
<!--SR:!2026-01-29,3,250-->

### UCS Optimality Condition
?
Under what condition is Uniform-Cost Search complete and optimal?
*   It is complete and optimal if the minimum action cost is strictly positive ($\epsilon > 0$).
*   If zero-cost steps exist, it can get stuck in infinite loops.
<!--SR:!2026-01-27,1,230-->

### Depth-First Search (DFS) Mechanics
?
Which node does DFS expand next, and what data structure is used for the frontier?
*   **Expansion:** It expands the **deepest** unexpanded node.
*   **Frontier:** It uses a **LIFO (Last-In-First-Out) queue** (or a Stack).
<!--SR:!2026-01-29,3,250-->

### DFS Complexity
?
What are the Time and Space complexities of Depth-First Search?
*   **Time:** $O(b^m)$ (Can be terrible if $m$ is much larger than $d$).
*   **Space:** $O(bm)$ (Linear space!).
*   *Note:* DFS is very memory efficient because it only stores the current path from root to leaf.
<!--SR:!2026-01-29,3,250-->

### DFS Drawbacks
?
What are the two main drawbacks of DFS?
1.  **Not Complete:** It can get stuck in infinite loops or infinite spaces.
2.  **Not Optimal:** It returns the first solution it finds, which might be a very long path (deep in the tree) rather than the shallowest.
<!--SR:!2026-01-30,4,270-->

### Depth-Limited Search
?
What is Depth-Limited Search and why is it used?
It is a variation of DFS that imposes a fixed depth limit $l$. It solves the problem of DFS getting stuck in infinite paths, but it introduces incompleteness (if the solution is deeper than $l$).
<!--SR:!2026-01-29,3,250-->

### Iterative Deepening Search (IDS)
?
How does Iterative Deepening Search work and what is its main advantage?
*   **Mechanism:** It runs Depth-Limited Search repeatedly with increasing depth limits ($limit = 0, 1, 2, ...$).
*   **Advantage:** It combines the **low space complexity** of DFS ($O(bd)$) with the **optimality and completeness** of BFS.
<!--SR:!2026-01-29,3,250-->

---

## Part 3: Informed (Heuristic) Search

### Heuristic Function
?
What is a heuristic function $h(n)$?
It is a function that estimates the cheapest cost from the state at node $n$ to the goal state.
*   $h(n) = 0$ if $n$ is the goal.
<!--SR:!2026-01-30,4,270-->

### Greedy Best-First Search
?
How does Greedy Search select the next node to expand?
It expands the node that appears closest to the goal according to the heuristic function (minimizes $h(n)$).
<!--SR:!2026-01-29,3,250-->

### Flaws of Greedy Search
?
Is Greedy Search optimal or complete?
*   **Optimal:** No. It often finds suboptimal solutions because it ignores the cost already paid ($g(n)$).
*   **Complete:** No. It can get stuck in loops (e.g., bouncing between Iasi and Neamt) unless repeated-state checking is used.
<!--SR:!2026-01-29,3,250-->

### A* Search Function
?
What is the evaluation function $f(n)$ used in A* search?
$$f(n) = g(n) + h(n)$$
*   **$g(n)$**: Cost so far to reach $n$.
*   **$h(n)$**: Estimated cost to goal from $n$.
*   **$f(n)$**: Estimated total cost of the best path passing through $n$.
<!--SR:!2026-01-30,4,270-->

### Admissibility
?
What does it mean for a heuristic to be **Admissible**?
The heuristic never overestimates the cost to the goal.
$$h(n) \leq h^*(n)$$
(Where $h^*(n)$ is the true cost).
*   *Required for A* to be optimal.*
<!--SR:!2026-01-30,4,270-->

### Consistency (Monotonicity)
?
What is a **Consistent** heuristic?
A heuristic that satisfies the triangle inequality:
$$h(n) \leq c(n, a, n') + h(n')$$
The estimated cost from $n$ is no greater than the cost to a successor $n'$ plus the estimated cost from $n'$.
*   Consistency implies Admissibility.
<!--SR:!2026-01-29,3,250-->

### A* Optimality Proof
?
Why does A* never select a suboptimal goal ($G_2$) for expansion if an optimal path exists?
Because any unexpanded node $n$ on the optimal path will have an $f$-value lower than the suboptimal goal.
$$f(n) \leq g(G_1) < g(G_2) = f(G_2)$$
Therefore, A* expands $n$ before $G_2$.
<!--SR:!2026-01-27,1,230-->

### Weighted A*
?
What is Weighted A* and why is it used?
*   **Formula:** $f(n) = g(n) + W \times h(n)$ where $W > 1$.
*   **Purpose:** It finds "satisficing" solutions (suboptimal but "good enough") faster than standard A* by expanding fewer nodes.
<!--SR:!2026-01-29,3,250-->

---

## Part 4: Designing Heuristics

### Dominating Heuristic
?
If heuristic $h_2(n) \geq h_1(n)$ for all $n$ (and both are admissible), which heuristic is better?
**$h_2$ dominates $h_1$.**
$h_2$ is better because it is closer to the true cost, meaning A* using $h_2$ will expand fewer nodes than A* using $h_1$.
<!--SR:!2026-01-27,1,230-->

### Relaxation
?
What is **Relaxation** in the context of heuristic design?
It involves simplifying the problem by removing constraints (e.g., in 8-puzzle, assuming tiles can slide through each other). The exact cost of the solution to the relaxed problem becomes an admissible heuristic for the original problem.
<!--SR:!2026-01-30,4,270-->

### Effective Branching Factor ($b^*$)
?
What is the Effective Branching Factor ($b^*$) and what does it indicate?
It is a metric to compare heuristics. If A\* finds a solution at depth $d$ using $N$ nodes, $b^*$ is the branching factor a uniform tree would need to contain $N$ nodes at depth $d$.
*   **Interpretation:** The closer $b^*$ is to 1, the better the heuristic.
<!--SR:!2026-01-27,1,230-->